From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 14 Jan 2025 15:50:29 -0800
Subject: feat: allow desktop capturer to return either screen, window or both
 and make MacOS SCContentSharingPicker work in Electron

This patch is a work in progress that contains assorted changes to make the MacOS SCContentSharingPicker upstream implementation work within Electron. If this comment is still in this patch during PR review, it is not ready for prime time

This patch can be removed after our desktopCapturer is refactored.

diff --git a/chrome/browser/media/webrtc/capture_policy_utils.cc b/chrome/browser/media/webrtc/capture_policy_utils.cc
index 85320190d406bdd37175ddb5d207d124b278b648..2fd7b9a89e2baebf5c5c4c2554c72d93c7ef0b0b 100644
--- a/chrome/browser/media/webrtc/capture_policy_utils.cc
+++ b/chrome/browser/media/webrtc/capture_policy_utils.cc
@@ -362,7 +362,9 @@ void FilterMediaList(std::vector<DesktopMediaList::Type>& media_types,
       media_types, [capture_level](const DesktopMediaList::Type& type) {
         switch (type) {
           case DesktopMediaList::Type::kNone:
-            NOTREACHED();
+            //TODO(review): are we able to remove this?
+            return capture_level < AllowedScreenCaptureLevel::kDesktop;
+            // NOTREACHED();
           // SameOrigin is more restrictive than just Tabs, so as long as
           // at least SameOrigin is allowed, these entries should stay.
           // They should be filtered later by the caller.
diff --git a/chrome/browser/media/webrtc/desktop_media_list_base.cc b/chrome/browser/media/webrtc/desktop_media_list_base.cc
index 08400be4d1bae18502d19beed6b2d9057e55dd4f..d83487885d566336d72bc5c4232d50a6a13ec3c2 100644
--- a/chrome/browser/media/webrtc/desktop_media_list_base.cc
+++ b/chrome/browser/media/webrtc/desktop_media_list_base.cc
@@ -12,9 +12,11 @@
 #include <set>
 #include <utility>
 
+#include "base/logging.h"
 #include "base/functional/bind.h"
 #include "base/hash/hash.h"
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -67,8 +69,9 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
       observer_->OnSourceAdded(i);
     }
   }
-
+  LOG(INFO)<< "Refresh callback_ is null: " << refresh_callback_.is_null() << ";";
   DCHECK(!refresh_callback_);
+  LOG(INFO) << "dcheck passed";
   refresh_callback_ = base::BindOnce(&DesktopMediaListBase::ScheduleNextRefresh,
                                      weak_factory_.GetWeakPtr());
   Refresh(true);
@@ -77,7 +80,13 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
 void DesktopMediaListBase::Update(UpdateCallback callback, bool refresh_thumbnails) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(sources_.empty());
-  DCHECK(!refresh_callback_);
+  #if BUILDFLAG(IS_MAC)
+   if (!ShouldUseSCContentSharingPicker()) {
+    DCHECK(!refresh_callback_);
+   };
+  #else
+    DCHECK(!refresh_callback_);
+  #endif
   refresh_callback_ = std::move(callback);
   Refresh(refresh_thumbnails);
 }
diff --git a/chrome/browser/media/webrtc/native_desktop_media_list.cc b/chrome/browser/media/webrtc/native_desktop_media_list.cc
index 0ac8e20073bd2db507e49200fd0b48f8535d666b..ffea8d7c257fc68a66a9804d45861131e4716b63 100644
--- a/chrome/browser/media/webrtc/native_desktop_media_list.cc
+++ b/chrome/browser/media/webrtc/native_desktop_media_list.cc
@@ -46,6 +46,7 @@
 #endif
 
 #if BUILDFLAG(IS_MAC)
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "components/remote_cocoa/browser/scoped_cg_window_id.h"
 #endif
 
@@ -186,9 +187,10 @@ content::DesktopMediaID::Type ConvertToDesktopMediaIDType(
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
-    case DesktopMediaList::Type::kNone:
       break;
   }
   NOTREACHED();
@@ -411,7 +413,8 @@ NativeDesktopMediaList::Worker::Worker(
                                 nullptr) {
   DCHECK(capturer_);
 
-  DCHECK(source_type_ == DesktopMediaID::Type::TYPE_WINDOW ||
+  DCHECK(source_type_ == DesktopMediaID::Type::TYPE_WINDOW || source_type_ ==
+             DesktopMediaID::Type::TYPE_NONE ||
          !add_current_process_windows_);
 }
 
@@ -545,17 +548,33 @@ NativeDesktopMediaList::Worker::FormatSources(
         break;
 
       case DesktopMediaID::Type::TYPE_WINDOW:
+      case DesktopMediaID::Type::TYPE_NONE:
+      #if BUILDFLAG(IS_MAC)
+              // If using NativeScreenCapturePickerMac,
+              // skipping the picker will skip the first window selection.
+              if (ShouldUseSCContentSharingPicker()) {
+                title = base::UTF8ToUTF16(sources[i].title);
+              } else if (sources[i].id == excluded_window_id) {
+              // Skip the picker dialog window.
+                continue;
+              }
+              title = base::UTF8ToUTF16(sources[i].title);
+      #else
         // Skip the picker dialog window.
         if (sources[i].id == excluded_window_id) {
           continue;
         }
         title = base::UTF8ToUTF16(sources[i].title);
+      #endif
         break;
 
       default:
         NOTREACHED();
     }
     DesktopMediaID source_id(source_type, sources[i].id);
+    // for each source log its id
+    for (size_t j = 0; j < sources.size(); ++j) {
+    }
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
     // We need to communicate this in_process_id to
     // |RefreshForVizFrameSinkWindows|, so we'll use the window_id. If
@@ -820,14 +839,10 @@ NativeDesktopMediaList::NativeDesktopMediaList(
       is_source_list_delegated_(capturer->GetDelegatedSourceListController() !=
                                 nullptr) {
   type_ = type;
-
-  DCHECK(type_ == DesktopMediaList::Type::kWindow ||
+  DCHECK(type_ == DesktopMediaList::Type::kWindow || type_ == DesktopMediaList::Type::kNone ||
          !add_current_process_windows_);
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
-  // webrtc::DesktopCapturer implementations on Windows, MacOS and Fuchsia
-  // expect to run on a thread with a UI message pump. Under Fuchsia the
-  // capturer needs an async loop to support FIDL I/O.
   base::MessagePumpType thread_type = base::MessagePumpType::UI;
 #else
   base::MessagePumpType thread_type = base::MessagePumpType::DEFAULT;
@@ -839,8 +854,9 @@ NativeDesktopMediaList::NativeDesktopMediaList(
       std::move(capturer), add_current_process_windows_,
       auto_show_delegated_source_list);
 
-  if (!is_source_list_delegated_)
+  if (!is_source_list_delegated_) {
     StartCapturer();
+  }
 }
 
 NativeDesktopMediaList::~NativeDesktopMediaList() {
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
index 12a74f8f32cc00a7f3d7802865ae4b309961341d..acbcfb08ae8c44e24a04b326096289428bc6ff60 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
@@ -8,6 +8,9 @@
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
 #include "chrome/browser/media/webrtc/thumbnail_capturer.h"
 
+// Returns true if the SCK sharing picker is available and enabled.
+bool ShouldUseSCContentSharingPicker();
+
 // Returns true if the SCK thumbnail capturer is available and enabled.
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type);
 
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
index 47a5ad2b7e2bc86a614488fd3fe85da1e3e2d6f2..fcc63aaf488b598db705e07274914eadffd29628 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
@@ -13,6 +13,7 @@
 #include <optional>
 #include <unordered_map>
 
+#include "base/logging.h"
 #include "base/apple/bridging.h"
 #include "base/apple/foundation_util.h"
 #include "base/apple/scoped_cftyperef.h"
@@ -80,11 +81,11 @@
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
       return content::DesktopMediaID::Type::TYPE_WEB_CONTENTS;
-    case DesktopMediaList::Type::kNone:
-      break;
   }
   NOTREACHED();
 }
@@ -480,7 +481,7 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
       minimum_window_size_(kThumbnailCapturerMacMinWindowSize.Get()),
       shareable_windows_([[NSArray<SCWindow*> alloc] init]) {
   CHECK(type_ == DesktopMediaList::Type::kWindow ||
-        type_ == DesktopMediaList::Type::kScreen);
+        type_ == DesktopMediaList::Type::kScreen || type_ == DesktopMediaList::Type::kNone);
 }
 
 ThumbnailCapturerMac::~ThumbnailCapturerMac() {
@@ -761,17 +762,18 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
                                       source_id);
 }
 
+}  // namespace
+
 bool ShouldUseSCContentSharingPicker() {
   if (@available(macOS 15.0, *)) {
     if (base::FeatureList::IsEnabled(media::kUseSCContentSharingPicker)) {
       return true;
     }
+    return false;
   }
   return false;
 }
 
-}  // namespace
-
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
   // There was a bug in ScreenCaptureKit that was fixed in 14.4,
   // see b/40076027.
@@ -785,6 +787,9 @@ bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
         return ShouldUseSCContentSharingPicker() ||
                base::FeatureList::IsEnabled(kScreenCaptureKitPickerScreen);
       case DesktopMediaList::Type::kNone:
+        return ShouldUseSCContentSharingPicker() ||
+               base::FeatureList::IsEnabled(kScreenCaptureKitStreamPickerSonoma) ||
+               base::FeatureList::IsEnabled(kScreenCaptureKitPickerScreen);
       case DesktopMediaList::Type::kCurrentTab:
       case DesktopMediaList::Type::kWebContents:
         return false;
diff --git a/content/browser/media/capture/desktop_capture_device.cc b/content/browser/media/capture/desktop_capture_device.cc
index 6618477648b7148ba66f5bb695be8eb6da045849..a8888d359324a826a2c8188e8631b643a8e1df5d 100644
--- a/content/browser/media/capture/desktop_capture_device.cc
+++ b/content/browser/media/capture/desktop_capture_device.cc
@@ -808,7 +808,6 @@ std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
     result.reset(new DesktopCaptureDevice(std::move(capturer), source.type));
     return result;
   }
-
   switch (source.type) {
     case DesktopMediaID::TYPE_SCREEN: {
       std::unique_ptr<webrtc::DesktopCapturer> screen_capturer;
@@ -829,7 +828,7 @@ std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
       }
       break;
     }
-
+    case DesktopMediaID::TYPE_NONE:
     case DesktopMediaID::TYPE_WINDOW: {
       std::unique_ptr<webrtc::DesktopCapturer> window_capturer;
       if (auto generic_capturer =
diff --git a/content/browser/media/capture/native_screen_capture_picker.cc b/content/browser/media/capture/native_screen_capture_picker.cc
index 152f3aa78032ee3f8c48fbefe052a2f1d85bed6b..d57df80dff9c6867cddf669efe3f90c43c03a0a7 100644
--- a/content/browser/media/capture/native_screen_capture_picker.cc
+++ b/content/browser/media/capture/native_screen_capture_picker.cc
@@ -7,6 +7,7 @@
 #if BUILDFLAG(IS_MAC)
 #include "content/browser/media/capture/native_screen_capture_picker_mac.h"
 #include "media/base/media_switches.h"
+#include "base/logging.h"
 #endif
 
 namespace content {
diff --git a/content/browser/media/capture/native_screen_capture_picker_mac.mm b/content/browser/media/capture/native_screen_capture_picker_mac.mm
index f3dbdd0db5f6c3d07b600f3dfa3267d0a5a57b81..2b37a27d37a994694855afed441ae82fe2671c90 100644
--- a/content/browser/media/capture/native_screen_capture_picker_mac.mm
+++ b/content/browser/media/capture/native_screen_capture_picker_mac.mm
@@ -138,8 +138,11 @@ void Open(DesktopMediaID::Type type,
     base::OnceClosure cancel_callback,
     base::OnceClosure error_callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // Chrome doesn't allow both screens & windows in their picker,
+  // but Electron does - add a check for TYPE_NONE.
   CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
-        type == DesktopMediaID::Type::TYPE_WINDOW);
+        type == DesktopMediaID::Type::TYPE_WINDOW ||
+        type == DesktopMediaID::Type::TYPE_NONE);
   if (@available(macOS 14.0, *)) {
     NSNumber* source_id = @(next_id_);
     auto picker_observer = [[PickerObserver alloc]
@@ -157,19 +160,26 @@ void Open(DesktopMediaID::Type type,
     // TODO(https://crbug.com/360781940): Add support for changing selected
     // content. The problem to solve is how this should interact with stream
     // restart.
-    config.allowsChangingSelectedContent = false;
+    config.allowsChangingSelectedContent = true;
     NSNumber* max_stream_count = @(kMaxContentShareCountValue.Get());
-    if (type == DesktopMediaID::Type::TYPE_SCREEN) {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
-    } else {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
-    }
+    // LOG(ERROR) << "Type: " << type;
+    // Chrome doesn't allow both screens & windows in their picker,
+    // but Electron does; we patch out the MediaID::Type conditional here
+    // if (type == DesktopMediaID::Type::TYPE_SCREEN) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
+    // } else if (type == DesktopMediaID::Type::TYPE_WINDOW) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
+    // } else {
+    picker.defaultConfiguration = config;
+    picker.maximumStreamCount = max_stream_count;
+    [picker present];
+    // }
   } else {
     NOTREACHED();
   }
@@ -209,7 +219,6 @@ void Open(DesktopMediaID::Type type,
     filter = [picker_observer contentFilter];
     cached_content_filters_[source_id] = filter;
   }
-
   return CreateScreenCaptureKitDeviceMac(source, filter);
 }
 
diff --git a/content/browser/media/capture/screen_capture_kit_device_mac.mm b/content/browser/media/capture/screen_capture_kit_device_mac.mm
index e99684a6b70f5d344cfcd4b1271c4abb349f3797..a2c3f28de65d35bc81a3d49c7ae777613a7a4b3e 100644
--- a/content/browser/media/capture/screen_capture_kit_device_mac.mm
+++ b/content/browser/media/capture/screen_capture_kit_device_mac.mm
@@ -340,6 +340,7 @@ void OnShareableContentCreated(SCShareableContent* content) {
             if (!fullscreen_module_) {
               fullscreen_module_ = MaybeCreateScreenCaptureKitFullscreenModule(
                   device_task_runner_, *this, window);
+            break;
             }
           }
         }
@@ -700,6 +701,7 @@ void ResetStreamTo(SCWindow* window) override {
     SCContentFilter* filter) {
   switch (source.type) {
     case DesktopMediaID::TYPE_SCREEN:
+    case DesktopMediaID::TYPE_NONE:
       // ScreenCaptureKitDeviceMac only supports a single display at a time.
       // It will not stitch desktops together. If
       // kScreenCaptureKitFullDesktopFallback is enabled, we will fallback to
diff --git a/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc b/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
index ee080009f75a0b9e07a12f929086008454ef8621..7163b1c4ce38a1ad0e0df105a6e28cf213934ae0 100644
--- a/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
+++ b/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
@@ -189,13 +189,13 @@ DesktopCaptureImplementation CreatePlatformDependentVideoCaptureDevice(
 #if BUILDFLAG(IS_MAC)
   // Use ScreenCaptureKit with picker if specified. `desktop_id` for the picker
   // is not compatible with the other implementations.
-  if (picker) {
-    device_out = picker->CreateDevice(desktop_id);
-    if (device_out) {
-      return kScreenCaptureKitDeviceMac;
-    }
-    return kNoImplementation;
-  }
+  // if (picker) {
+  //   device_out = picker->CreateDevice(desktop_id);
+  //   if (device_out) {
+  //     return kScreenCaptureKitDeviceMac;
+  //   }
+  //   return kNoImplementation;
+  // }
 
   // Prefer using ScreenCaptureKit. After that try DesktopCaptureDeviceMac, and
   // if both fail, use the generic DesktopCaptureDevice.
@@ -203,7 +203,9 @@ DesktopCaptureImplementation CreatePlatformDependentVideoCaptureDevice(
       (desktop_id.type == DesktopMediaID::TYPE_WINDOW &&
        base::FeatureList::IsEnabled(kScreenCaptureKitMacWindow)) ||
       (desktop_id.type == DesktopMediaID::TYPE_SCREEN &&
-       base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen))) {
+       base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen)) ||
+      (desktop_id.type == DesktopMediaID::TYPE_NONE &&
+       (base::FeatureList::IsEnabled(kScreenCaptureKitMacWindow) || base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen)))) {
     device_out = CreateScreenCaptureKitDeviceMac(desktop_id);
     if (device_out) {
       return kScreenCaptureKitDeviceMac;
@@ -249,6 +251,9 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
   DCHECK(state_ == State::READY_TO_LAUNCH);
 
   if (receiver_on_io_thread) {
+    LOG(INFO) << "InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync: Posting "
+                 "start request to device thread for device_id = "
+              << device_id;
     std::ostringstream string_stream;
     string_stream
         << "InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync: Posting "
@@ -269,12 +274,14 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
       base::BindPostTaskToCurrentDefault(base::BindOnce(
           &InProcessVideoCaptureDeviceLauncher::OnDeviceStarted,
           base::Unretained(this), callbacks, std::move(done_cb)));
-
+  LOG(INFO) << "stream type: " << stream_type;
+  LOG(INFO) << "gum tab video capture: " << blink::mojom::MediaStreamType::GUM_TAB_VIDEO_CAPTURE;
   switch (stream_type) {
-    case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
-      // Only the Service-based device launcher is supported for device capture
-      // from cameras etc.
-      NOTREACHED();
+    // case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
+    //   // Only the Service-based device launcher is supported for device capture
+    //   // from cameras etc.
+    //   LOG(INFO) << "device video capture not reached";
+    //   NOTREACHED();
 #if BUILDFLAG(ENABLE_SCREEN_CAPTURE)
     case blink::mojom::MediaStreamType::GUM_TAB_VIDEO_CAPTURE:
       start_capture_closure = base::BindOnce(
@@ -286,10 +293,10 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
     case blink::mojom::MediaStreamType::GUM_DESKTOP_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE_THIS_TAB:
+    case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE_SET: {
       const DesktopMediaID desktop_id = DesktopMediaID::Parse(device_id);
-      if (desktop_id.is_null()) {
-        DLOG(ERROR) << "Desktop media ID is null";
+      if (desktop_id.is_null() && desktop_id.id != DesktopMediaID::kMacOsNativePickerId) {
         start_capture_closure =
             base::BindOnce(std::move(after_start_capture_callback), nullptr);
         break;
@@ -331,6 +338,7 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
 #if defined(USE_AURA)
       bool allow_window_id = false;
 #elif BUILDFLAG(IS_MAC)
+
       bool allow_window_id =
         desktop_id.id == DesktopMediaID::kMacOsNativePickerId;
 #endif
@@ -517,7 +525,8 @@ void InProcessVideoCaptureDeviceLauncher::DoStartDesktopCaptureOnDeviceThread(
     std::unique_ptr<media::VideoCaptureDeviceClient> device_client,
     ReceiveDeviceCallback result_callback) {
   DCHECK(device_task_runner_->BelongsToCurrentThread());
-  DCHECK(!desktop_id.is_null());
+  LOG(INFO) << "desktop id: " << desktop_id.id;
+  // DCHECK(!desktop_id.is_null());
 
   std::unique_ptr<media::VideoCaptureDevice> video_capture_device;
   DesktopCaptureImplementation implementation =
diff --git a/content/browser/renderer_host/media/in_process_video_capture_provider.cc b/content/browser/renderer_host/media/in_process_video_capture_provider.cc
index 4462efa154a2be9cc25f82688fdbc7edf71a7bb1..4207dd1a79c16df5cc972943da32699f414f81fa 100644
--- a/content/browser/renderer_host/media/in_process_video_capture_provider.cc
+++ b/content/browser/renderer_host/media/in_process_video_capture_provider.cc
@@ -9,6 +9,7 @@
 #include "base/functional/bind.h"
 #include "base/task/single_thread_task_runner.h"
 #include "content/browser/renderer_host/media/in_process_video_capture_device_launcher.h"
+#include "content/browser/media/capture/native_screen_capture_picker.h"
 
 namespace content {
 
diff --git a/content/public/browser/desktop_media_id.cc b/content/public/browser/desktop_media_id.cc
index b39b684ff84baaf292eef1a23b7f9fb4585023c5..55507f7a782a9472800221f1e908618a5bad2914 100644
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -21,6 +21,7 @@ namespace content {
 
 const char kScreenPrefix[] = "screen";
 const char kWindowPrefix[] = "window";
+const char kNonePrefix[] = "none";
 
 #if defined(USE_AURA) || BUILDFLAG(IS_MAC)
 // static
@@ -82,6 +83,8 @@ DesktopMediaID DesktopMediaID::Parse(const std::string& str) {
     type = TYPE_SCREEN;
   } else if (parts[0] == kWindowPrefix) {
     type = TYPE_WINDOW;
+  } else if (parts[0] == kNonePrefix) {
+    type = TYPE_NONE;
   } else {
     return DesktopMediaID();
   }
@@ -104,6 +107,8 @@ std::string DesktopMediaID::ToString() const {
   std::string prefix;
   switch (type) {
     case TYPE_NONE:
+      prefix = kNonePrefix;
+      break;
       NOTREACHED();
     case TYPE_SCREEN:
       prefix = kScreenPrefix;
